/*

    Generated by chatgpt.com, May 25 2025.

*/

#include <ncurses.h>
#include <stdint.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>

void to_upper(char *str) {
    while (*str) {
        *str = toupper((unsigned char)*str);
        str++;
    }
}


/* STACK */

#define STACK_SIZE 128

int32_t stack[STACK_SIZE];
int sp = -1;  // stack pointer

void push(int32_t val) {
    if (sp < STACK_SIZE - 1)
        stack[++sp] = val;
}

int32_t pop() {
    if (sp >= 0)
        return stack[sp--];
    return 0;
}

int32_t peek() {
    if (sp >= 0)
        return stack[sp];
    return 0;
}


/* MEMORY */

#define MEM_SIZE 256

typedef enum {
    TYPE_NUMBER,
    TYPE_POINTER,
    TYPE_BYTES
} MemType;

typedef struct {
    uint32_t value;
    MemType type;
} MemoryCell;

MemoryCell memory[MEM_SIZE];

void init_memory() {
    for (int i = 0; i < MEM_SIZE; ++i) {
        memory[i].value = i * 10;
        memory[i].type = i % 3;
    }
}

void draw_memory(WINDOW *win) {
    werase(win);
    box(win, 0, 0);
    int rows, cols;
    getmaxyx(win, rows, cols);
    cols -= 2;
    int cols_per_line = cols / 12;

    for (int i = 0; i < MEM_SIZE; ++i) {
        int row = i / cols_per_line + 1;
        int col = (i % cols_per_line) * 12 + 1;

        if (row >= rows - 1) break;

        // Color by type
        wattron(win, COLOR_PAIR(memory[i].type + 1));
        switch (memory[i].type) {
            case TYPE_NUMBER:
                mvwprintw(win, row, col, "%03d: %d", i, memory[i].value);
                break;
            case TYPE_POINTER:
                mvwprintw(win, row, col, "%03d: 0x%08X", i, memory[i].value);
                break;
            case TYPE_BYTES: {
                char str[5];
                uint32_t val = memory[i].value;
                for (int j = 0; j < 4; ++j) {
                    char c = (val >> (8 * (3 - j))) & 0xFF;
                    str[j] = isprint(c) ? c : '.';
                }
                str[4] = '\0';
                mvwprintw(win, row, col, "%03d: '%s'", i, str);
                break;
            }
        }
        wattroff(win, COLOR_PAIR(memory[i].type + 1));
    }
    wrefresh(win);
}

void draw_stack(WINDOW *win) {
    werase(win);
    box(win, 0, 0);
    mvwprintw(win, 0, 2, " Stack ");
    int max_y, max_x;
    getmaxyx(win, max_y, max_x);

    int display_limit = max_y - 2;
    int start = sp - display_limit + 1;
    if (start < 0) start = 0;

    for (int i = 0; i <= sp && i - start < display_limit; ++i) {
        mvwprintw(win, max_y - 2 - (i - start), 2, "[%2d] %d", i, stack[i]);
    }

    wrefresh(win);
}

void execute_command_OLD(const char *cmd) {
    // Basic Forth-style example commands: SET 10 123, TYPE 10 POINTER
    char keyword[16];
    int addr, val;
    if (sscanf(cmd, "SET %d %d", &addr, &val) == 2) {
        if (addr >= 0 && addr < MEM_SIZE)
            memory[addr].value = val;
    } else if (sscanf(cmd, "TYPE %d %s", &addr, keyword) == 2) {
        if (addr >= 0 && addr < MEM_SIZE) {
            if (strcmp(keyword, "NUMBER") == 0)
                memory[addr].type = TYPE_NUMBER;
            else if (strcmp(keyword, "POINTER") == 0)
                memory[addr].type = TYPE_POINTER;
            else if (strcmp(keyword, "BYTES") == 0)
                memory[addr].type = TYPE_BYTES;
        }
    }
}

void execute_command(const char *cmd) {
    char token[32];
    int offset = 0;

    while (sscanf(cmd + offset, "%31s", token) == 1) {
        offset += strlen(token);
        while (isspace(cmd[offset])) offset++; // skip whitespace

        if (strcmp(token, "PUSH") == 0) {
            int val;
            if (sscanf(cmd + offset, "%d", &val) == 1) {
                push(val);
                while (isdigit(cmd[offset]) || cmd[offset] == '-') offset++;
            }
        } else if (strcmp(token, "POP") == 0) {
            pop();
        } else if (strcmp(token, "DUP") == 0) {
            push(peek());
        } else if (strcmp(token, "SWAP") == 0) {
            if (sp >= 1) {
                int32_t a = pop();
                int32_t b = pop();
                push(a);
                push(b);
            }
        } else if (strcmp(token, "+") == 0) {
            if (sp >= 1) push(pop() + pop());
        } else if (strcmp(token, "-") == 0) {
            if (sp >= 1) {
                int32_t b = pop();
                int32_t a = pop();
                push(a - b);
            }
        } else if (strcmp(token, "*") == 0) {
            if (sp >= 1) push(pop() * pop());
        } else if (strcmp(token, "/") == 0) {
            if (sp >= 1) {
                int32_t b = pop();
                int32_t a = pop();
                if (b != 0) push(a / b);
                else push(0);
            }
        } else if (strcmp(token, "@") == 0) {
            int addr;
            if (sscanf(cmd + offset, "%d", &addr) == 1 && addr >= 0 && addr < MEM_SIZE) {
                push(memory[addr].value);
                while (isdigit(cmd[offset])) offset++;
            }
        } else if (strcmp(token, "!") == 0) {
            int addr;
            if (sscanf(cmd + offset, "%d", &addr) == 1 && addr >= 0 && addr < MEM_SIZE) {
                memory[addr].value = pop();
                while (isdigit(cmd[offset])) offset++;
            }
        } else if (strcmp(token, "TYPE") == 0) {
            int addr;
            char tname[16];
            if (sscanf(cmd + offset, "%d %15s", &addr, tname) == 2) {
                if (addr >= 0 && addr < MEM_SIZE) {
                    if (strcmp(tname, "NUMBER") == 0)
                        memory[addr].type = TYPE_NUMBER;
                    else if (strcmp(tname, "POINTER") == 0)
                        memory[addr].type = TYPE_POINTER;
                    else if (strcmp(tname, "BYTES") == 0)
                        memory[addr].type = TYPE_BYTES;
                }
                offset += strlen(tname) + 1;
            }
        }
    }
}

int main() {
    initscr();
    cbreak();
    //noecho();
    keypad(stdscr, TRUE);
    start_color();
    use_default_colors();

    init_pair(1, COLOR_GREEN, -1);   // NUMBER
    init_pair(2, COLOR_CYAN, -1);    // POINTER
    init_pair(3, COLOR_YELLOW, -1);  // BYTES

    int height, width;
    getmaxyx(stdscr, height, width);

    int mem_height = height * 7 / 10;
    int stack_height = height * 2 / 10;
    int input_height = height - mem_height - stack_height;

    WINDOW *mem_win = newwin(mem_height, width, 0, 0);
    WINDOW *stack_win = newwin(stack_height, width, mem_height, 0);
    WINDOW *cmd_win = newwin(input_height, width, mem_height + stack_height, 0);

    scrollok(cmd_win, TRUE);

    init_memory();
    draw_memory(mem_win);
    draw_stack(stack_win);

    char input[256];
    while (1) {
        werase(cmd_win);
        box(cmd_win, 0, 0);
        mvwprintw(cmd_win, 1, 2, ">>> ");
        wrefresh(cmd_win);
        wgetnstr(cmd_win, input, sizeof(input) - 1);
        to_upper(input);

        if (strncmp(input, "EXIT", 4) == 0)
            break;

        execute_command(input);
        draw_memory(mem_win);
        draw_stack(stack_win);
    }

    endwin();
    return 0;
}
